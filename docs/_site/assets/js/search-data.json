{
  "1": {
    "id": "1",
    "title": "Assets",
    "content": "assets stuff all about assets Caustics Libraries/ROSBridgeLib CustomMessages geometry_msgs sensor_msgs std_msgs ROSBridgeMsg.cs ROSBridgePublisher.cs Materials skybox/sky.mat Bubble.mat BubbleMaterial.mat Models Vehicle.obj defaultMat.mat gate.obj green 1.obj red 1.obj Prefabs Water/Materials Water/Models Water/Prefabs Water/Scripts Water/Shaders Water/Textures Publishers CompressedImagePublisher.cs DepthPublisher.cs HeadingPublisher.cs imuPublisher.cs Scenes Simulation.unity Testbed.unity Scripts AUV.cs BoatPhysics.cs Buoyancy.cs Collision.cs Surface.cs Teleop.cs WaterController.cs Standard Assets CrossPlatformInput/Prefabs CrossPlatformInput/Scripts CrossPlatformInput/Sprites Editor/ Effects/ Environment/ Utility/ Subscribers DepthThrusterCallback.cs ImuSubscriberCallback.cs VectorThrusterCallback.cs Caustics caustic renders bmp images Libraries/ROSBridgeLib CustomMessages geometry_msgs sensor_msgs std_msgs ROSBridgeMsg.cs ROSBridgePublisher.cs Materials The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). skybox/sky.mat Bubble.mat BubbleMaterial.mat Models The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). Vehicle.obj defaultMat.mat gate.obj green 1.obj red 1.obj Prefabs Water/Materials Water/Models Water/Prefabs Water/Scripts Water/Shaders Water/Textures The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). Publishers The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). CompressedImagePublisher.cs DepthPublisher.cs HeadingPublisher.cs imuPublisher.cs Scenes The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). Simulation.unity Testbed.unity Scripts The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). AUV.cs BoatPhysics.cs Buoyancy.cs Collision.cs Surface.cs Teleop.cs WaterController.cs Standard Assets The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). CrossPlatformInput/Prefabs CrossPlatformInput/Scripts CrossPlatformInput/Sprites Editor/ Effects/ Environment/ Utility/ Subscribers The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). DepthThrusterCallback.cs ImuSubscriberCallback.cs VectorThrusterCallback.cs",
    "url": "http://localhost:4000/docs/repo_navigation/unity/Assets",
    "relUrl": "/docs/repo_navigation/unity/Assets"
  },
  "2": {
    "id": "2",
    "title": "ProjectSettings",
    "content": "assets stuff all about assets ProjectSettings AudioManager.asset ClusterInputManager.asset DynamicsManager.asset EditorSettings.asset NetworkManager.asset TimeManager.asset ProjectSettings AudioManager.asset ClusterInputManager.asset DynamicsManager.asset EditorSettings.asset NetworkManager.asset TimeManager.asset",
    "url": "http://localhost:4000/docs/repo_navigation/unity/ProjectSettings",
    "relUrl": "/docs/repo_navigation/unity/ProjectSettings"
  },
  "3": {
    "id": "3",
    "title": "Action Servers and Clients",
    "content": "Action Servers The mission planner used in the simulation system is a high level module based on the concept of finite state machines. Mission planning is the key to achieve intelligent behaviour in an autonomous system. It consists of an apparatus for top-down decomposition of states where each state represents a task that the robot needs to perform.Real-world complex behaviors can be developed using hierarchical and concurrent state machines to perform tasks like motion in different degrees of freedom, object detection and obstacle avoidance. The mission planner based on the above concept has been implemented using the SMACH package provided by ROS. The mission planner contains low level states for motion of the vehicle along or about each possible degree of freedom - Roll, Pitch, Yaw, Surge, Sway and Heave. Using combinations of these low level states, higher level sub-missions can be developed. The state hierarchy diagram depicts the tree structure for the developed mission. Mission planner works internally as follows: mission_planner.py main() calls listener(). listener() creates a new node called mission_planner. The node subscribes to a topic called /zsys and calls the callback(). The callback() calls main() where an object called sm of StateMachine is created with 3 outcomes - [‘mission_complete’, ‘mission_failed’, ‘aborted’] sm performs 3 tasks - sink to a certain depth, align to a certain heading, move forward for some seconds. Sink (sm, &#39;SINK1&#39;, 515, &#39;HEADING1&#39;) Heading(sm, &#39;HEADING1&#39;, 75,&#39;FORWARD1&#39;) Forward(sm, &#39;FORWARD1&#39;, 6, &#39;FORWARD2&#39;) Forward(sm, &#39;FORWARD2&#39;, 12, &#39;mission_complete&#39;) Sink.py &amp; Depth.py Sink (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;pressure&gt;, &lt;next state&gt;) In Sink.py the Sink class’s constructor is called which sets the initial pressure. A substate called sm_sub is created with outcomes as [‘depth_success’, ‘aborted’]. sm_sub creates an object called depthTask of the class Depth. depthTask = Depth(INITIAL_PRESSURE, &#39;depth_success&#39;)The Depth.py’s constructor sets the values of pressure and task variables. depthTask.addDepthAction(smach_StateMachine) calls the addDepthAction(self, sm) method of class Depth where a new SimpleActionState DEPTH is added to sm and depthCallback() is called, transitions being ‘succeeded’:self.TASK, ‘preempted’:’DEPTH’, ‘aborted’:’aborted’. In depthCallback(), the depth_setpoint is set to PRESSURE’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the PRESSURE as the goal and returns ‘DepthReached’/’aborted’. Heading.py Heading (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;heading&gt;, &lt;next state&gt;) In Heading.py the Heading class’s constructor is called which sets the initial heading. A new SimpleActionState heading1 is added to sm and headingCallback() is called.. In headingCallback(), the heading_setpoint is set to HEADING’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the HEADING as the goal and returns ‘HeadingReached’/’aborted’. Forward.py Forward (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;time&gt;, &lt;next state&gt;) Creates a SimpleActionState called surgeServer, calls goalCallback() to move the Underwater Vehicle forward for the time sent from mission_planner.py.",
    "url": "http://localhost:4000/docs/action_servers",
    "relUrl": "/docs/action_servers"
  },
  "4": {
    "id": "4",
    "title": "Actions and Messages",
    "content": "Actions and Messages Messages ROS uses a simplified messages description language for describing the data values (aka messages) that ROS nodes publish. This description makes it easy for ROS tools to automatically generate source code for the message type in several target languages. Message descriptions are stored in .msg files in the msg/ subdirectory of a ROS package. There are two parts to a .msg file: fields and constants. Fields are the data that is sent inside of the message. Constants define useful values that can be used to interpret those fields (e.g. enum-like constants for an integer value). Each field consists of a type and a name, separated by a space, i.e.: fieldtype1 fieldname1 fieldtype2 fieldname2 fieldtype3 fieldname3 For example: int32 x int32 y There are 2 msg files each used by one of the thruster nodes: DepthThrusterMsg.msg Contains 4 variables - td1, td2, td3, td4 of type uint16. Each of the variables store the pwm values for the 4 depth thrusters. VectorThrusterMsg.msg Contains 4 variables - tfr, tfl, trr, trl of type uint16 where: fr: front right fl: front left rr: rear right rl: rear left Each of the variables store the pwm values for the 4 heading thrusters. Actions In order for the client and server to communicate, we need to define a few messages on which they communicate. This is with an action specification. This defines the Goal, Feedback, and Result messages with which clients and servers communicate: Goal To accomplish tasks using actions, we introduce the notion of a goal that can be sent to an ActionServer by an ActionClient. In the case of moving the base, the goal would be a PoseStamped message that contains information about where the robot should move to in the world. For controlling the tilting laser scanner, the goal would contain the scan parameters (min angle, max angle, speed, etc). Feedback Feedback provides server implementers a way to tell an ActionClient about the incremental progress of a goal. For moving the base, this might be the robot’s current pose along the path. For controlling the tilting laser scanner, this might be the time left until the scan completes. Result A result is sent from the ActionServer to the ActionClient upon completion of the goal. This is different than feedback, since it is sent exactly once. This is extremely useful when the purpose of the action is to provide some sort of information. For move base, the result isn’t very important, but it might contain the final pose of the robot. For controlling the tilting laser scanner, the result might contain a point cloud generated from the requested scan. .action file The action specification is defined using a .action file. The .action file has the goal definition, followed by the result definition, followed by the feedback definition, with each section separated by 3 hyphens (—). These files are placed in a package’s ./action directory, and look extremely similar to a service’s .srv file. An action specification for doing the dishes might look like the following: ./action/DoDishes.action # Define the goal uint32 dishwasher_id # Specify which dishwasher we want to use # Define the result uint32 total_dishes_cleaned # Define a feedback message float32 percent_complete There are 3 .action files used: dept.action Has 3 fields - depth_setpoint, depth_final, depth_destination heading.action Has 3 fields - heading_setpoint, heading_final, heading_destination time.action Has 3 fields - time_setpoint, time_final, time_destination",
    "url": "http://localhost:4000/docs/action_msgs",
    "relUrl": "/docs/action_msgs"
  },
  "5": {
    "id": "5",
    "title": "communication",
    "content": "Communication stuff has comm stuff scripts controlClients.py scripts The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). controlClients.py",
    "url": "http://localhost:4000/docs/repo_navigation/ros/src/communication",
    "relUrl": "/docs/repo_navigation/ros/src/communication"
  },
  "6": {
    "id": "6",
    "title": "control",
    "content": "Control stuff has control stuff action heave.action roll.action pitch.action yaw.action surge.action sway.action cfg thruster.cfg launch msg thruster.msg scripts thruster.py servers roll.py pitch.py yaw.py heave.py sway.py surge.py action The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). heave.action roll.action pitch.action yaw.action surge.action sway.action cfg The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). thruster.cfg this is the thruster config file launch The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). msg The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). thruster.msg scripts The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). thruster.py servers The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). roll.py pitch.py yaw.py heave.py sway.py surge.py",
    "url": "http://localhost:4000/docs/repo_navigation/ros/src/control",
    "relUrl": "/docs/repo_navigation/ros/src/control"
  },
  "7": {
    "id": "7",
    "title": "Vision and Darknet",
    "content": "Vision and Darknet The mission planner used in the simulation system is a high level module based on the concept of finite state machines. Mission planning is the key to achieve intelligent behaviour in an autonomous system. It consists of an apparatus for top-down decomposition of states where each state represents a task that the robot needs to perform.Real-world complex behaviors can be developed using hierarchical and concurrent state machines to perform tasks like motion in different degrees of freedom, object detection and obstacle avoidance. The mission planner based on the above concept has been implemented using the SMACH package provided by ROS. The mission planner contains low level states for motion of the vehicle along or about each possible degree of freedom - Roll, Pitch, Yaw, Surge, Sway and Heave. Using combinations of these low level states, higher level sub-missions can be developed. The state hierarchy diagram depicts the tree structure for the developed mission. Mission planner works internally as follows: mission_planner.py main() calls listener(). listener() creates a new node called mission_planner. The node subscribes to a topic called /zsys and calls the callback(). The callback() calls main() where an object called sm of StateMachine is created with 3 outcomes - [‘mission_complete’, ‘mission_failed’, ‘aborted’] sm performs 3 tasks - sink to a certain depth, align to a certain heading, move forward for some seconds. Sink (sm, &#39;SINK1&#39;, 515, &#39;HEADING1&#39;) Heading(sm, &#39;HEADING1&#39;, 75,&#39;FORWARD1&#39;) Forward(sm, &#39;FORWARD1&#39;, 6, &#39;FORWARD2&#39;) Forward(sm, &#39;FORWARD2&#39;, 12, &#39;mission_complete&#39;) Sink.py &amp; Depth.py Sink (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;pressure&gt;, &lt;next state&gt;) In Sink.py the Sink class’s constructor is called which sets the initial pressure. A substate called sm_sub is created with outcomes as [‘depth_success’, ‘aborted’]. sm_sub creates an object called depthTask of the class Depth. depthTask = Depth(INITIAL_PRESSURE, &#39;depth_success&#39;)The Depth.py’s constructor sets the values of pressure and task variables. depthTask.addDepthAction(smach_StateMachine) calls the addDepthAction(self, sm) method of class Depth where a new SimpleActionState DEPTH is added to sm and depthCallback() is called, transitions being ‘succeeded’:self.TASK, ‘preempted’:’DEPTH’, ‘aborted’:’aborted’. In depthCallback(), the depth_setpoint is set to PRESSURE’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the PRESSURE as the goal and returns ‘DepthReached’/’aborted’. Heading.py Heading (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;heading&gt;, &lt;next state&gt;) In Heading.py the Heading class’s constructor is called which sets the initial heading. A new SimpleActionState heading1 is added to sm and headingCallback() is called.. In headingCallback(), the heading_setpoint is set to HEADING’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the HEADING as the goal and returns ‘HeadingReached’/’aborted’. Forward.py Forward (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;time&gt;, &lt;next state&gt;) Creates a SimpleActionState called surgeServer, calls goalCallback() to move the Underwater Vehicle forward for the time sent from mission_planner.py.",
    "url": "http://localhost:4000/docs/darknet",
    "relUrl": "/docs/darknet"
  },
  "8": {
    "id": "8",
    "title": "Home",
    "content": "URSim | Documentation URSim on GitHub View our Paper You have arrived at the documentation of URSim - an open source 3D underwater simulation framework for Unmanned Underwater Vehicles (UUVs) developed using Robotics Operating System (ROS) and a real-time game engine called Unity3D. URSim provides the user an intuitive way to simulate underwater vehicles and robots. The software architecture is adaptive to algorithms for control systems, image processing, navigation and manipulation. Our paper - Simulator for Unmanned Underwater Vehicles using ROS and Unity3D to be presented at UT’19 IEEE-OES conference on April 17 ‘19 URSim features Feedback control system simulation Support for dynamic models Mission planning for underwater vehicles and robots Underwater vision URSim provides support for Underwater sensor modules Underwater physics Collision kinematics",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "9": {
    "id": "9",
    "title": "Mission Planner",
    "content": "Mission Planner The mission planner used in the simulation system is a high level module based on the concept of finite state machines. Mission planning is the key to achieve intelligent behaviour in an autonomous system. It consists of an apparatus for top-down decomposition of states where each state represents a task that the robot needs to perform.Real-world complex behaviors can be developed using hierarchical and concurrent state machines to perform tasks like motion in different degrees of freedom, object detection and obstacle avoidance. The mission planner based on the above concept has been implemented using the SMACH package provided by ROS. The mission planner contains low level states for motion of the vehicle along or about each possible degree of freedom - Roll, Pitch, Yaw, Surge, Sway and Heave. Using combinations of these low level states, higher level sub-missions can be developed. The state hierarchy diagram depicts the tree structure for the developed mission. Mission planner works internally as follows: mission_planner.py main() calls listener(). listener() creates a new node called mission_planner. The node subscribes to a topic called /zsys and calls the callback(). The callback() calls main() where an object called sm of StateMachine is created with 3 outcomes - [‘mission_complete’, ‘mission_failed’, ‘aborted’] sm performs 3 tasks - sink to a certain depth, align to a certain heading, move forward for some seconds. Sink (sm, &#39;SINK1&#39;, 515, &#39;HEADING1&#39;) Heading(sm, &#39;HEADING1&#39;, 75,&#39;FORWARD1&#39;) Forward(sm, &#39;FORWARD1&#39;, 6, &#39;FORWARD2&#39;) Forward(sm, &#39;FORWARD2&#39;, 12, &#39;mission_complete&#39;) Sink.py &amp; Depth.py Sink (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;pressure&gt;, &lt;next state&gt;) In Sink.py the Sink class’s constructor is called which sets the initial pressure. A substate called sm_sub is created with outcomes as [‘depth_success’, ‘aborted’]. sm_sub creates an object called depthTask of the class Depth. depthTask = Depth(INITIAL_PRESSURE, &#39;depth_success&#39;)The Depth.py’s constructor sets the values of pressure and task variables. depthTask.addDepthAction(smach_StateMachine) calls the addDepthAction(self, sm) method of class Depth where a new SimpleActionState DEPTH is added to sm and depthCallback() is called, transitions being ‘succeeded’:self.TASK, ‘preempted’:’DEPTH’, ‘aborted’:’aborted’. In depthCallback(), the depth_setpoint is set to PRESSURE’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the PRESSURE as the goal and returns ‘DepthReached’/’aborted’. Heading.py Heading (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;heading&gt;, &lt;next state&gt;) In Heading.py the Heading class’s constructor is called which sets the initial heading. A new SimpleActionState heading1 is added to sm and headingCallback() is called.. In headingCallback(), the heading_setpoint is set to HEADING’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the HEADING as the goal and returns ‘HeadingReached’/’aborted’. Forward.py Forward (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;time&gt;, &lt;next state&gt;) Creates a SimpleActionState called surgeServer, calls goalCallback() to move the Underwater Vehicle forward for the time sent from mission_planner.py.",
    "url": "http://localhost:4000/docs/mission_planner",
    "relUrl": "/docs/mission_planner"
  },
  "10": {
    "id": "10",
    "title": "mission planner",
    "content": "mission planner few lines on mission planner launch MissionPlanner.launch scripts Heave.py Pitch.py Roll.py Sink.py Surge.py Sway.py Yaw.py launch The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). MissionPlanner.launch scripts The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). Heave.py Pitch.py Roll.py Sink.py Surge.py Sway.py Yaw.py",
    "url": "http://localhost:4000/docs/repo_navigation/ros/src/mission_planner",
    "relUrl": "/docs/repo_navigation/ros/src/mission_planner"
  },
  "11": {
    "id": "11",
    "title": "Navigating the repository",
    "content": "What is where in the repository Description of every file in every folder in the repository can be found by navigating down this tree.",
    "url": "http://localhost:4000/docs/repo_navigation",
    "relUrl": "/docs/repo_navigation"
  },
  "12": {
    "id": "12",
    "title": "ros",
    "content": "ROS contains all the ros code files.",
    "url": "http://localhost:4000/docs/repo_navigation/ros",
    "relUrl": "/docs/repo_navigation/ros"
  },
  "13": {
    "id": "13",
    "title": "Search",
    "content": "Search Set up search Generate search index Enable search in configuration Hiding pages from search Just the Docs uses lunr.js to add a client-side search interface powered by a JSON index that Jekyll generates. All search results are shown in an auto-complete style interface (there is no search results page). By default, all generated HTML pages are indexed using the following data points: Page title Page content Page URL Set up search Generate search index Before you can use search, you must initialize the feature by running this rake command that comes with just-the-docs: $ bundle exec just-the-docs rake search:init This command creates the search-data.json file that Jekyll uses to create your search index. Alternatively, you can create the file manually in the assets/js/ directory of your Jekyll site with this content: {% raw %} { {% for page in site.html_pages %}{% if page.search_exclude != true %}&quot;{{ forloop.index0 }}&quot;: { &quot;id&quot;: &quot;{{ forloop.index0 }}&quot;, &quot;title&quot;: &quot;{{ page.title | replace: &#39;&amp;amp;&#39;, &#39;&amp;&#39; }}&quot;, &quot;content&quot;: &quot;{{ page.content | markdownify | strip_html | escape_once | remove: &#39;&#39; | remove: &#39;&#39; | remove: &#39;&#39; | replace: &#39; &#39;, &#39; &#39; | normalize_whitespace }}&quot;, &quot;url&quot;: &quot;{{ page.url | absolute_url }}&quot;, &quot;relUrl&quot;: &quot;{{ page.url }}&quot; }{% unless forloop.last %},{% endunless %} {% endif %}{% endfor %} }{% endraw %} Note: If you don’t run this rake command or create this file manually, search will not work (or it will use the search index data from this docs site, not your site’s content). Enable search in configuration In your site’s _config.yml, enable search: # Enable or disable the site search search_enabled: true Hiding pages from search Sometimes you might have a page that you don’t want to be indexed for the search nor to show up in search results, e.g, a 404 page. To exclude a page from search, add the search_exclude: true parameter to the page’s YAML front matter: Example layout: default title: Page not found nav_exclude: true search_exclude: true",
    "url": "http://localhost:4000/docs/search/",
    "relUrl": "/docs/search/"
  },
  "14": {
    "id": "14",
    "title": "sensors",
    "content": "sensor stuff has sensor stuff…as of now empty",
    "url": "http://localhost:4000/docs/repo_navigation/ros/src",
    "relUrl": "/docs/repo_navigation/ros/src"
  },
  "15": {
    "id": "15",
    "title": "Thrusters",
    "content": "Thrusters Mission planner works internally as follows: mission_planner.py main() calls listener(). listener() creates a new node called mission_planner. The node subscribes to a topic called /zsys and calls the callback(). The callback() calls main() where an object called sm of StateMachine is created with 3 outcomes - [‘mission_complete’, ‘mission_failed’, ‘aborted’] sm performs 3 tasks - sink to a certain depth, align to a certain heading, move forward for some seconds. Sink (sm, &#39;SINK1&#39;, 515, &#39;HEADING1&#39;) Heading(sm, &#39;HEADING1&#39;, 75,&#39;FORWARD1&#39;) Forward(sm, &#39;FORWARD1&#39;, 6, &#39;FORWARD2&#39;) Forward(sm, &#39;FORWARD2&#39;, 12, &#39;mission_complete&#39;) Sink.py &amp; Depth.py Sink (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;pressure&gt;, &lt;next state&gt;) In Sink.py the Sink class’s constructor is called which sets the initial pressure. A substate called sm_sub is created with outcomes as [‘depth_success’, ‘aborted’]. sm_sub creates an object called depthTask of the class Depth. depthTask = Depth(INITIAL_PRESSURE, &#39;depth_success&#39;)The Depth.py’s constructor sets the values of pressure and task variables. depthTask.addDepthAction(smach_StateMachine) calls the addDepthAction(self, sm) method of class Depth where a new SimpleActionState DEPTH is added to sm and depthCallback() is called, transitions being ‘succeeded’:self.TASK, ‘preempted’:’DEPTH’, ‘aborted’:’aborted’. In depthCallback(), the depth_setpoint is set to PRESSURE’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the PRESSURE as the goal and returns ‘DepthReached’/’aborted’. Heading.py Heading (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;heading&gt;, &lt;next state&gt;) In Heading.py the Heading class’s constructor is called which sets the initial heading. A new SimpleActionState heading1 is added to sm and headingCallback() is called.. In headingCallback(), the heading_setpoint is set to HEADING’s value.’ From mission_planner.py, execute() is called which creates a SimpleActionClient and sends the HEADING as the goal and returns ‘HeadingReached’/’aborted’. Forward.py Forward (&lt;state machine object&gt;, &lt;name of state&gt;, &lt;time&gt;, &lt;next state&gt;) Creates a SimpleActionState called surgeServer, calls goalCallback() to move the Underwater Vehicle forward for the time sent from mission_planner.py.",
    "url": "http://localhost:4000/docs/thrusters",
    "relUrl": "/docs/thrusters"
  },
  "16": {
    "id": "16",
    "title": "unity",
    "content": "ROS contains all the ros code files.",
    "url": "http://localhost:4000/docs/repo_navigation/unity",
    "relUrl": "/docs/repo_navigation/unity"
  },
  "17": {
    "id": "17",
    "title": "Guided",
    "content": "Guided Introduction Welcome to step by step tutorials for the users with little or no experience using URSim. The steps will guide you through the most basic usage of URSim. We will run a simple prebuilt scene in Unity and connect it to ROS. You will find the guidelines to so the following tasks ahead: Downloading and installing ROS, Unity and other required packages. Setting up URSim on windows and connecting it to ROS running on Ubuntu. Running your first simulation on URSim. Downloading and installing ROS, Unity Ubuntu 16.04LTS Instructions for installing Ubuntu 16.04LTS can be found here. Please stick to Ubuntu 16.Xs only. ROS Instructions for installing ROS Kinetic Kame can be found here. Please stick to ROS Kinetic Kame only. Unity You can download Unity3D from here and install it by running the executable file downloaded. Setting up the repository and URSim Setting up repository In your Ubuntu terminal enter the following command to git clone the URSim repository:git clone https://github.com/srmauvsoftware/URSim.git Source your environnment:source /opt/ros/kinetic/setup.bashCreate a new catkin workspace:mkdir -p ~/catkin_ws/srccd ~/catkin_ws/catkin_make Copy the contents of ros directory to the new workspace:cd /path/to/repo/ros ~/catkin_ws/src Install rosbridge:sudo apt-get install ros-kinetic-rosbridge-suite Port forwarding:Open your web browser and enter the url for opening the configuration page of your router somewhat similar to the examples below:TP Link Routers: http://192.168.0.1Asus Routers: http://192.168.1.1 Find the option for port forwarding. It could be in security settings or advanced setting. Add a new port and ip address to forward and save the settings then restart the router. Setting up URSim On your Windows machine, download the repository from here. Extract the downloaded zip file. Navigate to /path/to/repo/URSim-master/unity/Assets/Scripts and open the file AUV.cs. Edit the ip address and the forwarded port of your ubuntu machine in the following line in the file: ros = new ROSBridgeWebSocketConnection (&quot;&lt;ip address&gt;&quot;, &lt;port&gt;); for example: ros = new ROSBridgeWebSocketConnection (&quot;ws://192.168.0.100&quot;, 9090); Runnning simulations and using ROS launch files Running the simulation Launch Unity3D and after signing in/skipping, click on ‘open’ icon at the top right of the window. Navigate to /path/to/repo/URSim-master/unity/ to select the project. When the project opens, click on file-&gt;open scene and navigate to pathtorepo URSim-master unity Assets Scenes and select the scene to run. Using ROS launch files Launch files in ROS are very common to both users and developers. They provide a convenient way to start up multiple nodes and a master, as well as other initialization requirements such as setting up parameters. The launch files are written in xml roslaunch is used to open launch files. This is done by specifying the package the launch files are contained in followed by the name of the launch file. We have placed all the launch files in URSim/ros/src/mission_planner/launch/. You can run these launch files as follows: roslaunch launch &lt;launch_file_name&gt;. Eg. roslaunch launch depth_controller.launch. Make sure you have sourced the repository before running any commands. We provide you with the following launch files: Launch files for controllers heave_controller.launch launches the ‘controller’ node from package ‘pid’ under the namespace ‘heave_controller’. Sets values to the following parameters - kp, ki, kd upper_limit, lower_limit, windup_limit max_loop_frequency, min_loop_frequency Remaps ‘setpoint’ to ‘/depth_setpoint’ ‘state’ to ‘/depth’ ‘control_effort’ to ‘/heave_controller/control_effort’ yaw_controller.launch launches the ‘controller’ node from package ‘pid’ under the namespace ‘yaw_controller’. Sets values to the following parameters - kp, ki, kd upper_limit, lower_limit, windup_limit max_loop_frequency, min_loop_frequency Remaps ‘setpoint’ to ‘/heading_setpoint’ ‘state’ to ‘/imu/HeadingTrue_degree/theta’ ‘control_effort’ to ‘/yaw_controller/control_effort’ sway_controller.launch launches the ‘controller’ node from package ‘pid’ under the namespace ‘sway_controller’. Sets values to the following parameters - kp, ki, kd upper_limit, lower_limit, windup_limit max_loop_frequency, min_loop_frequency Remaps ‘setpoint’ to ‘/sway_scale_setpoint’ ‘state’ to ‘/sway_scale/’ ‘control_effort’ to ‘/sway_controller/control_effort’ surge_controller.launch launches the ‘controller’ node from package ‘pid’ under the namespace ‘surge_controller’. Sets values to the following parameters - kp, ki, kd upper_limit, lower_limit, windup_limit max_loop_frequency, min_loop_frequency Remaps ‘setpoint’ to ‘/surge_scale_setpoint’ ‘state’ to ‘/surge_scale/’ ‘control_effort’ to ‘/surge_controller/control_effort’ controllers.launch launches all four controllers - heave, sway, yaw, surge. Launch files for thrusters depth_thruster.launch Launches the node ‘depthThrusters’ in package ‘thrusters’ vector_thruster.launch Launches the node ‘vectorThrusters’ in package ‘thrusters’ thrusters.launch Launches both the nodes - ‘depth_thrusters’ and ‘vectorThrusters’",
    "url": "http://localhost:4000/docs/user/",
    "relUrl": "/docs/user/"
  },
  "18": {
    "id": "18",
    "title": "vision",
    "content": "vision stuff has vision stuff…as of now empty",
    "url": "http://localhost:4000/docs/repo_navigation/ros/src",
    "relUrl": "/docs/repo_navigation/ros/src"
  }
  
}
